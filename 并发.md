# 1、基础

## 1、基础

- 锁定的是对象

- synchronized与Reentrantlock是可重入锁（可重入指的是可重入对象），即一个线程可以同时执行同一个对象中的另一个同步方法

- 锁定不会锁定非同步方法，即读和写有一个不锁定，读出来的结果就有可能不正确

- 程序执行过程中抛出异常会释放锁

- volatile只保证了可见性，不保证原子性

- AtomicXXX多个方法执行并不具有原子性

- 不要以字符串常量作为锁对象，因为有可能会产生死锁

- 使用notifyAll而不是notify，因为notify有可能会唤醒本来阻塞掉的对象，使程序阻塞
- 当不涉及同步，只涉及线程间通信唤醒等时，使用锁太重，可以考虑使用countdownlatch/cyclicbarrier/semaphore

```java
CountDownLatch countDownLatch = new CountDownLatch(1);
countDownLatch.countDown();
```

## 2、高并发容器

- ConcurrentMap
- CopyOnWriteArrayList
- Collections.synchronizedXXX ()
- ConcurrentQueue
- LinkedBlockingQueue
- ArrayBlockingQueue
- DelayBlockingQueue
- TransferBlockingQueue
- SynchronusQueue

## 3、ThreadLocal

## 4、线程池

- Executor
- ExecutorService
- Callable
- Executors
- ThreadPool
- Future
- ParallelComputing
- CachePool
- fixedPool
- SingleThreadPool
- ScheduledPool
- workStealingPool
- ForkJoinPool
- ThreadPoolExecutor
- parallelStreamApi
